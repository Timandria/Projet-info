
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <stdbool.h> //pour les boolÃ©ens

#define S "0"//reSet color
#define L "1"//add light to the color
#define D "2"//assombrie les caractÃ¨re
#define E "22"//anule les effet L et D
#define V "31"//rouge car R est dÃ©ja pris
#define G "32"//vert 
#define Y "33"//jaune
#define B "34"//bleu 
#define M "35"//magenta
#define C "36"//cyan
#define W "37"//blanc

#define PCOLOR(X) "\x1b["X"m"    //macro pour ajouter la couleur facilement, le X est l'emplacement du code couleur, au forma "nombre"
typedef struct case_tableau {
    char caractere;
    bool variable;
    int TAILLE;
} case_tableau;







void Affichage(case_tableau tab[][20], int taille) {
    int i, j, k, l;
    
    for (i = 0; i < taille; i++) {
        printf("\n \n");
        
        for (l = 0; l < taille; l++) {
            if (l == taille - 1) {
                printf("+---+\n"); // Ligne de fin de sÃ©paration
                break;
            } else {
                printf("+---"); // Ligne Ã  multiplier de sÃ©paration
            }
        }
        
        for (k = 0; k < taille; k++) {
            if (tab[i][k].variable == 1) {
                printf("|");
                printf("\x1b[31m O ");
                printf(PCOLOR("%d"), 0);
            } else if (tab[i][k].caractere == 'A') {
                printf("|");
                printf("\x1b[32m A ");
                printf(PCOLOR("%d"), 0);
            } else if (tab[i][k].caractere == 'B') {
                printf("|");
                printf("\x1b[33m B ");
                printf(PCOLOR("%d"), 0);
            } else if (tab[i][k].caractere == 'C') {
                printf("|");
                printf("\x1b[34m C ");
                printf(PCOLOR("%d"), 0);
            } else if (tab[i][k].caractere == 'D') {
                printf("|");
                printf("\x1b[35m D ");
                printf(PCOLOR("%d"), 0);
            } else if (tab[i][k].caractere == 'E') {
                printf("|");
                printf("\x1b[36m E ");
                printf(PCOLOR("%d"), 0);
            } else if (tab[i][k].caractere == 'F') {
                printf("|");
                printf("\x1b[37m F ");
                printf(PCOLOR("%d"), 0);
            }
        }
        printf("|"); // Barre de fin
    }
    
    printf("\n");
    
    for (l = 0; l < taille; l++) {
        if (l == taille - 1) {
            printf("+---+\n"); // Ligne de fin de sÃ©paration
        } 
        else {
            printf("+---"); // Ligne Ã  multiplier de sÃ©paration
        }
    }
}



void Affichagemoji(case_tableau tab[][20],int taille){ // Affichage du tableau Ã  modifier pendant la sÃ©ance d'info
    int i,j,k,l,m;
        for(i=0;i<taille;i++){
            printf("\n \n");
            if(i==0){
                for(m=0;m<taille;m++){        //affichage des chiffres en hauteur
                    printf("   %d.",m);
                }
                printf("\n ");      
            }
            for (l = 0; l < taille; l++) {
                if (l == taille - 1) {
                    printf("+----+\n"); // Ligne de fin de sÃ©paration
                    break;
                } 
                else {
                printf("+----"); // Ligne Ã  multiplier de sÃ©paration
                }
            }
                for(k=0;k<taille;k++){
                    if(k==0){
                printf("%d",i);   
            }
            if(tab[i][k].variable==1){
                printf("|");
                printf("\x1b[31m O ");
                printf(PCOLOR("%d"),0);
                
            }
            else if(tab[i][k].caractere=='A'){
                printf("|");
                printf(" ğŸ ");
                
            }
            else if(tab[i][k].caractere=='B'){
                printf("|");
                printf(" ğŸ‰ ");
            }
            else if(tab[i][k].caractere=='C'){
                printf("|");
                printf(" ğŸ¥ ");
                
            }
            else if(tab[i][k].caractere=='D'){
                printf("|");
                printf(" ğŸ‡ ");
                
            }
            else if(tab[i][k].caractere=='E'){
                printf("|");
                printf(" ğŸ§ ");
                printf(PCOLOR("%d"),0);
            }
            else if(tab[i][k].caractere=='F'){
                printf("|");
                printf(" ğŸ¥• ");
                printf(PCOLOR("%d"),0);
            }
        }
        printf("|"); // Barre de fin
    } 
    printf("\n");
    
    for (l = 0; l < taille; l++) {
        if (l == taille - 1) {
            printf("+----+\n"); // Ligne de fin de sÃ©paration
        } 
        else{
            printf("+----"); // Ligne Ã  multiplier de sÃ©paration
        }
    }
}

bool detecteMarque(case_tableau tab[][20],int taille,bool veriftot) {
    int ol, oc; // optimisation fin du k en ligne et colonne
    bool verif = 0;
    veriftot = 0; // boolÃ©en pour vÃ©rifier qu'il ne reste aucune ligne ou colonne de 3 ou plus
    int i, j, k, l, m, o;
    
    for (int i = 0; i < taille; i++) {
        ol=taille;
        for (int j = 0; j < ol; j++) {
            if(j==0){
                oc=taille;
                int compteur = 1; // initialisation des compteurs Ã  1
                int compteurinf=1;
                while (compteur < taille && tab[i][compteur].caractere == tab[i][j].caractere) {
                compteur++; // compter le nombre d'Ã©lÃ©ments Ã©gaux vers la droite
                }
                while (taille-compteurinf >=0 && tab[i][taille - compteurinf].caractere == tab[i][0].caractere) {
                compteurinf++; // compter le nombre d'Ã©lÃ©ments Ã©gaux vers la droite
                }
                if (compteur >= 3&&compteurinf<=1) { // si on a trouvÃ© une sÃ©rie d'au moins 3 Ã©lÃ©ments Ã©gaux
                    for (int k = 0; k < compteur; k++) {
                        tab[i][k].variable=1; // remplacer les Ã©lÃ©ments par des "O"
                    }
                    veriftot=1;
                }
                if ((compteurinf >= 3&&compteur<=1)){
                    tab[i][0].variable=1; // remplacer du premier Ã©lÃ©ments par un "O"
                    for (int k = taille+1-compteurinf; k < taille ; k++) {
                        tab[i][k].variable=1; // remplacer les Ã©lÃ©ments par des "O"
                    }
                    ol=taille-compteurinf; //optimisation fin de ligne
                    veriftot=1;
                }
                if (compteurinf+compteur>=4&&compteur>=1&&compteurinf>=1){
                    for (int k = 0; k < compteur; k++) {
                        tab[i][k].variable=1; // remplacer les Ã©lÃ©ments par des "O"
                    }
                    for (int k = taille + 1 - compteurinf; k<taille ; k++) {
                        tab[i][k].variable=1; // remplacer les Ã©lÃ©ments par des "O"
                    }
                    ol=taille-compteurinf; //optimisation fin de ligne
                    veriftot=1;
                }
            }
            if(i==0){
                int compteur = 1; // rÃ©initialisation des compteurs Ã  1
                int compteurinf=1; 
                while (taille-compteurinf >=0 && tab[taille - compteurinf][j].caractere == tab[i][j].caractere) {
                compteurinf++; // compter le nombre d'Ã©lÃ©ments Ã©gaux vers la droite
                }
                while (compteur < taille && tab[i + compteur][j].caractere == tab[i][j].caractere) {
                    compteur++; // compter le nombre d'Ã©lÃ©ments Ã©gaux vers le bas
                }
                if (compteur >= 3&&compteurinf==1) { // si on a trouvÃ© une sÃ©rie d'au moins 3 Ã©lÃ©ments Ã©gaux
                    for (int k = 0; k < compteur; k++) {
                        tab[k][j].variable=1; // remplacer les Ã©lÃ©ments par des "O"
                        veriftot=1;
                        
                    }
                }
                if (compteurinf >= 3&&compteur==1){
                    tab[0][j].variable=1; // remplacer du premier Ã©lÃ©ments par un "O"
                    for (int k = taille+1-compteurinf; k <taille ; k++) {
                        tab[k][j].variable=1; // remplacer les Ã©lÃ©ments par des "O"
                        veriftot=1;
                        
                    }
                oc=taille-compteurinf;
                }
                if (compteurinf+compteur>=4&&compteur!=1&&compteurinf!=1){
                    for (int k = 0; k < compteur; k++) {
                        tab[k][j].variable=1; // remplacer les Ã©lÃ©ments par des "O"
                    }
                    for (int k = taille+1 -compteurinf; k < taille; k++) {
                        tab[k][j].variable=1; // remplacer les Ã©lÃ©ments par des "O"
                       
                    }
                oc=taille-compteurinf; //optimisation fin de ligne
                veriftot=1;
                }
            }
            int compteur = 1; // initialisation du compteur Ã  1
            while (j + compteur < taille && tab[i][j + compteur].caractere == tab[i][j].caractere) {
                compteur++; // compter le nombre d'Ã©lÃ©ments Ã©gaux vers la droite
            }
            if (compteur >= 3) { // si on a trouvÃ© une sÃ©rie d'au moins 3 Ã©lÃ©ments Ã©gaux
                for (int k = 0; k < compteur; k++) {
                    tab[i][j+k].variable=1; // remplacer les Ã©lÃ©ments par des "O"
                }
            }
            compteur = 1; // rÃ©initialisation du compteur Ã  1
            while (i + compteur < taille && tab[i + compteur][j].caractere == tab[i][j].caractere) {
                compteur++; // compter le nombre d'Ã©lÃ©ments Ã©gaux vers le bas
            }
            if (compteur >= 3) { // si on a trouvÃ© une sÃ©rie d'au moins 3 Ã©lÃ©ments Ã©gaux
                for (int k = 0; k < compteur; k++) {
                    tab[i+k][j].variable=1; // remplacer les Ã©lÃ©ments par des "O"
                }
            }
        
        
        
            for (int j = 0; j < taille; j++) {
                int compteur = 1; // initialisation du compteur Ã  1
                while (j + compteur < taille && tab[i][j + compteur].caractere == tab[i][j].caractere) {
                    compteur++; // compter le nombre d'Ã©lÃ©ments Ã©gaux vers la droite
                }
                if (compteur >= 3) { // si on a trouvÃ© une sÃ©rie d'au moins 3 Ã©lÃ©ments Ã©gaux
                    for (int k = 0; k < compteur; k++) {
                        tab[i][j+k].variable=1; // remplacer les Ã©lÃ©ments par des "O"
                    }
                    veriftot=1;
                }
                compteur = 1; // rÃ©initialisation du compteur Ã  1
                while (i + compteur < taille && tab[i + compteur][j].caractere == tab[i][j].caractere) {
                    compteur++; // compter le nombre d'Ã©lÃ©ments Ã©gaux vers le bas
                }
                if (compteur >= 3) { // si on a trouvÃ© une sÃ©rie d'au moins 3 Ã©lÃ©ments Ã©gaux
                    for (int k = 0; k < compteur; k++) {
                        tab[i+k][j].variable=1; // remplacer les Ã©lÃ©ments par des "O"
                    }
                    veriftot=1;
                }
            }
        }        
    }
    return veriftot;
}

void DeplacerGauche(case_tableau tab[][20],int taille) {
    int i,j,k;
    bool verif=0;
    
    
    
    for (i = 0; i < taille; i++) {
        for (j = 0; j < taille; j++) {
            if (tab[i][j].variable == 1) {
                k = j;
                while (k > 0 && tab[i][k - 1].variable == 0) {
                    // Ã‰changer le caractÃ¨re (avec son boolÃ©en prÃ©cÃ©dent!!!!)
                    char tempCaractere = tab[i][k - 1].caractere;
                    int tempVariable = tab[i][k - 1].variable;
                    tab[i][k - 1].caractere = tab[i][k].caractere;
                    tab[i][k - 1].variable = tab[i][k].variable;
                    tab[i][k].caractere = tempCaractere;
                    tab[i][k].variable = tempVariable;
                    k--;
                }
            }
        }
    }


    

}


void remplacement(case_tableau tab[][20],int taille,int different){
    int i, j, k;
    bool vÃ©rif=0;
    bool vÃ©riftot;
    int taille2;
    taille2=taille;
    
    
    do{             // remplacement de tout les caractÃ¨res avec un boolÃ©en = 1 
        vÃ©riftot=detecteMarque(tab,taille2,vÃ©riftot); // vÃ©riftot ici sert Ã  dÃ©tecter si le programme detecteMarque change une variable d'un caractÃ¨re 
        DeplacerGauche(tab,taille2);
        for(i=0;i<taille;i++){
            vÃ©rif=0;
            for(k=0;k<taille;k++){ // GÃ©nÃ©ration alÃ©atoire des caractÃ¨res
                if(tab[i][k].variable==1){
                    vÃ©rif=1;
                    tab[i][k].caractere='A'+rand()%different; //  symboles diffÃ©rents choisi par l'utilisateur
                    tab[i][k].variable=0; // variable Ã  zero pour le compteur
                }
            }
        }
        
    }while(vÃ©rif==1 || vÃ©riftot==1);    //le do while ici sert pour ne pas sortir de la boucle tant que un des deux boolÃ©ens est Ã©gale Ã  1
}
void echange(case_tableau tab[][20],int taille){
  int a1, b1, a2, b2;    //a1 : ligne de la 1Ã¨re case Ã  Ã©changer et b1 : colonne de cette 1Ã¨re case
                         // pareil pour a2 et b2
  a1=0;
  b1=0;
  a2=0;
  b2=0;
  
  //boucle pour recommencer aprÃ¨s chaque Ã©change  
  int erreur=0; 
  while(erreur==0){ 
    char case1, case2;
  
    
    do{  //pour vÃ©rifier l'inverse : on veut que les a et b soient compris entre 0 et _ inclus
      printf("\nDonnez les coordonnÃ©es de la 1Ã¨re case : ligne, puis colonne\n"); 
      scanf("%d",&a1);
      scanf("%d",&b1);
    }while (a1<0 || a1>taille || b1<0 || b1>taille );
    case1=tab[a1][b1].caractere;
    
    printf("case1: ");
    if(case1=='A'){
      printf(" ğŸ \n");
    }
    else if(case1=='B'){
      printf(" ğŸ‰ \n");
    }
    else if(case1=='C'){
      printf(" ğŸ¥ \n");
    }
    else if(case1=='D'){
      printf(" ğŸ‡ \n");               
    }
    else if(case1=='E'){
      printf(" ğŸ§ \n");
      //printf(PCOLOR("%d"),0);
    }
    else if(case1=='F'){
      printf(" ğŸ¥• \n");
      //printf(PCOLOR("%d"),0);
    }





    do{
      printf("Donnez les coordonnÃ©es de la 2nd case : ligne, puis colonne\n");
      scanf("%d",&a2);
      scanf("%d",&b2);
    }while (a2<0 || a2>taille || b2<0 || b2>taille);
    case2=tab[a2][b2].caractere;

    printf("case2: ");
    if(case2=='A'){
      printf(" ğŸ \n");
    }
    else if(case2=='B'){
      printf(" ğŸ‰ \n");
    }
    else if(case2=='C'){
      printf(" ğŸ¥ \n");
    }
    else if(case2=='D'){
      printf(" ğŸ‡ \n");               
    }
    else if(case2=='E'){
      printf(" ğŸ§ \n");
      //printf(PCOLOR("%d"),0);
    }
    else if(case2=='F'){
      printf(" ğŸ¥• \n");
      //printf(PCOLOR("%d"),0);
    }





    
  if (((a1==a2)&&((b1==b2+1)||(b1==b2-1))) || ((b1==b2)&&((a1==a2+1)||(a1==a2-1)))){  //condition pour vÃ©rifier que les cases soient Ã  cÃ´tÃ©s ou au-dessus/dessous
    printf("condition ok\n");
    case1=tab[a2][b2].caractere;    //Ã©change de la case1 par la case2
    case2=tab[a1][b1].caractere;    //pareil mais pour case2 par case1

    printf("case1 Ã©changÃ©e: ");
    if(case1=='A'){
      printf(" ğŸ \n");
    }
    else if(case1=='B'){
      printf(" ğŸ‰ \n");
    }
    else if(case1=='C'){
      printf(" ğŸ¥ \n");
    }
    else if(case1=='D'){
      printf(" ğŸ‡ \n");               
    }
    else if(case1=='E'){
      printf(" ğŸ§ \n");
      //printf(PCOLOR("%d"),0);
    }
    else if(case1=='F'){
      printf(" ğŸ¥• \n");
      //printf(PCOLOR("%d"),0);
    }


    printf("case2 Ã©changÃ©e: ");
    if(case2=='A'){
      printf(" ğŸ \n");
    }
    else if(case2=='B'){
      printf(" ğŸ‰ \n");
    }
    else if(case2=='C'){
      printf(" ğŸ¥ \n");
    }
    else if(case2=='D'){
      printf(" ğŸ‡ \n");               
    }
    else if(case2=='E'){
      printf(" ğŸ§ \n");
      //printf(PCOLOR("%d"),0);
    }
    else if(case2=='F'){
      printf(" ğŸ¥• \n");
      //printf(PCOLOR("%d"),0);
    }


    
    
  }
  else if((a1==a2)&&((b1==0 && b2==taille-1)||(b1==taille-1 && b2==0))){    //condition spÃ©ciale oÃ¹ les 2 cases Ã  Ã©changer sont aux extrÃªmitÃ©s de la mÃªme ligne
    printf("ok ligne\n");  //pour vÃ©rifier cette codition
    case1=tab[a2][b2].caractere;     //Ã©change
    case2=tab[a1][b1].caractere;

    printf("case1 Ã©changÃ©e: ");
    if(case1=='A'){
      printf(" ğŸ \n");
    }
    else if(case1=='B'){
      printf(" ğŸ‰ \n");
    }
    else if(case1=='C'){
      printf(" ğŸ¥ \n");
    }
    else if(case1=='D'){
      printf(" ğŸ‡ \n");               
    }
    else if(case1=='E'){
      printf(" ğŸ§ \n");
      //printf(PCOLOR("%d"),0);
    }
    else if(case1=='F'){
      printf(" ğŸ¥• \n");
      //printf(PCOLOR("%d"),0);
    }


    
    printf("case2 Ã©changÃ©e: ");
    if(case2=='A'){
      printf(" ğŸ \n");
    }
    else if(case2=='B'){
      printf(" ğŸ‰ \n");
    }
    else if(case2=='C'){
      printf(" ğŸ¥ \n");
    }
    else if(case2=='D'){
      printf(" ğŸ‡ \n");               
    }
    else if(case2=='E'){
      printf(" ğŸ§ \n");
      //printf(PCOLOR("%d"),0);
    }
    else if(case2=='F'){
      printf(" ğŸ¥• \n");
      //printf(PCOLOR("%d"),0);
    }



    
  }
  else if((b1==b2)&&((a1==0 && a2==taille-1)||(a1==taille-1 && a2==0))){ //condition spÃ©ciale oÃ¹ les 2 cases Ã  Ã©changer sont aux extrÃªmitÃ©s de la mÃªme colonne
    printf("ok colonne\n");
    case1=tab[a2][b2].caractere;
    case2=tab[a1][b1].caractere;
    
    printf("case1 Ã©changÃ©e: ");
    if(case1=='A'){
      printf(" ğŸ \n");
    }
    else if(case1=='B'){
      printf(" ğŸ‰ \n");
    }
    else if(case1=='C'){
      printf(" ğŸ¥ \n");
    }
    else if(case1=='D'){
      printf(" ğŸ‡ \n");               
    }
    else if(case1=='E'){
      printf(" ğŸ§ \n");
      //printf(PCOLOR("%d"),0);
    }
    else if(case1=='F'){
      printf(" ğŸ¥• \n");
      //printf(PCOLOR("%d"),0);
    }






    printf("case2 Ã©changÃ©e: ");
    if(case2=='A'){
      printf(" ğŸ \n");
    }
    else if(case2=='B'){
      printf(" ğŸ‰ \n");
    }
    else if(case2=='C'){
      printf(" ğŸ¥ \n");
    }
    else if(case2=='D'){
      printf(" ğŸ‡ \n");               
    }
    else if(case2=='E'){
      printf(" ğŸ§ \n");
      //printf(PCOLOR("%d"),0);
    }
    else if(case2=='F'){
      printf(" ğŸ¥• \n");
      //printf(PCOLOR("%d"),0);
    }
    
  }

    
  else {  //erreur car : coordonnÃ©es corresponds pas ou cases pas Ã  cÃ´tÃ©s
    printf("\nErreur\nRefaire:\n\n");
  }

//afficher tbl aprÃ¨s l'Ã©change : ??

}  

}







    





int main() {
    int taille;
    int different;
    
    do {
        printf("Entrez la taille du tableau (entre 5 et 20) : ");
        scanf("%d", &taille);
    } while (taille < 5 || taille > 20);
    
    do {
        printf("Entrez le nombre de forme diffÃ©rentes (entre 4 et 6) : ");
        scanf("%d", &different);
    } while (different < 4 || different > 6);
    
    case_tableau tab[20][20]; // DÃ©finition du tableau
    
    srand(time(NULL)); // GÃ©nÃ©ration alÃ©atoire
    
    int i, k;
    for (i = 0; i < taille; i++) {
        for (k = 0; k < taille; k++) {
        // GÃ©nÃ©ration alÃ©atoire des caractÃ¨res
        tab[i][k].caractere = 'A' + rand() % different; //  symboles diffÃ©rents choisit lors du scanf
        tab[i][k].variable = 0; // variable Ã  zÃ©ro pour le compteur
    }
}


remplacement(tab, taille,different);
Affichage(tab, taille);
echange(tab,taille);
Affichage(tab, taille);

return 0;
}
















